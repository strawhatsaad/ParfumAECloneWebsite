"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tester-box/page",{

/***/ "(app-pages-browser)/./src/lib/cart.ts":
/*!*************************!*\
  !*** ./src/lib/cart.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addBundleToCart: function() { return /* binding */ addBundleToCart; },\n/* harmony export */   getCart: function() { return /* binding */ getCart; },\n/* harmony export */   removeFromCart: function() { return /* binding */ removeFromCart; }\n/* harmony export */ });\n/* harmony import */ var _shopify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shopify */ \"(app-pages-browser)/./src/lib/shopify.ts\");\n\nconst CART_FRAGMENT = \"\\n  id\\n  checkoutUrl\\n  cost {\\n    totalAmount {\\n      amount\\n      currencyCode\\n    }\\n  }\\n  lines(first: 100) {\\n    edges {\\n      node {\\n        id\\n        quantity\\n        merchandise {\\n          ... on ProductVariant {\\n            id\\n            title\\n            product {\\n              title\\n              featuredImage {\\n                url\\n                altText\\n              }\\n            }\\n            price {\\n              amount\\n              currencyCode\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n\";\nconst CREATE_CART_MUTATION = \"\\n  mutation cartCreate($input: CartInput!) {\\n    cartCreate(input: $input) {\\n      cart {\\n        \".concat(CART_FRAGMENT, \"\\n      }\\n    }\\n  }\\n\");\nconst ADD_TO_CART_MUTATION = \"\\n  mutation cartLinesAdd($cartId: ID!, $lines: [CartLineInput!]!) {\\n    cartLinesAdd(cartId: $cartId, lines: $lines) {\\n      cart {\\n       \".concat(CART_FRAGMENT, \"\\n      }\\n    }\\n  }\\n\");\nasync function addBundleToCart(cartId, testerBoxVariantId, bundleItems) {\n    const lineItemProperties = bundleItems.map((item, index)=>({\n            key: \"Tester \".concat(index + 1),\n            value: item.title\n        }));\n    const line = {\n        merchandiseId: testerBoxVariantId,\n        quantity: 1,\n        attributes: lineItemProperties\n    };\n    if (cartId) {\n        const data = await (0,_shopify__WEBPACK_IMPORTED_MODULE_0__.shopifyFetch)({\n            query: ADD_TO_CART_MUTATION,\n            variables: {\n                cartId,\n                lines: [\n                    line\n                ]\n            }\n        });\n        return data.cartLinesAdd.cart.id;\n    } else {\n        const data = await (0,_shopify__WEBPACK_IMPORTED_MODULE_0__.shopifyFetch)({\n            query: CREATE_CART_MUTATION,\n            variables: {\n                input: {\n                    lines: [\n                        line\n                    ]\n                }\n            }\n        });\n        return data.cartCreate.cart.id;\n    }\n}\n// **NEW FUNCTIONS BELOW**\nconst GET_CART_QUERY = \"\\n  query getCart($cartId: ID!) {\\n    cart(id: $cartId) {\\n      \".concat(CART_FRAGMENT, \"\\n    }\\n  }\\n\");\nasync function getCart(cartId) {\n    const data = await (0,_shopify__WEBPACK_IMPORTED_MODULE_0__.shopifyFetch)({\n        query: GET_CART_QUERY,\n        variables: {\n            cartId\n        }\n    });\n    return data.cart;\n}\nconst REMOVE_FROM_CART_MUTATION = \"\\n  mutation cartLinesRemove($cartId: ID!, $lineIds: [ID!]!) {\\n    cartLinesRemove(cartId: $cartId, lineIds: $lineIds) {\\n      cart {\\n        \".concat(CART_FRAGMENT, \"\\n      }\\n    }\\n  }\\n\");\nasync function removeFromCart(cartId, lineId) {\n    const data = await (0,_shopify__WEBPACK_IMPORTED_MODULE_0__.shopifyFetch)({\n        query: REMOVE_FROM_CART_MUTATION,\n        variables: {\n            cartId,\n            lineIds: [\n                lineId\n            ]\n        }\n    });\n    return data.cartLinesRemove.cart;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY2FydC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXlDO0FBcUN6QyxNQUFNQyxnQkFBaUI7QUEyQ3ZCLE1BQU1DLHVCQUF1Qix5R0FJTCxPQUFkRCxlQUFjO0FBTXhCLE1BQU1FLHVCQUF1QixrSkFJTixPQUFkRixlQUFjO0FBTWhCLGVBQWVHLGdCQUNwQkMsTUFBcUIsRUFDckJDLGtCQUEwQixFQUMxQkMsV0FBc0I7SUFFdEIsTUFBTUMscUJBQXFCRCxZQUFZRSxHQUFHLENBQUMsQ0FBQ0MsTUFBTUMsUUFBVztZQUMzREMsS0FBSyxVQUFvQixPQUFWRCxRQUFRO1lBQ3ZCRSxPQUFPSCxLQUFLSSxLQUFLO1FBQ25CO0lBRUEsTUFBTUMsT0FBTztRQUNYQyxlQUFlVjtRQUNmVyxVQUFVO1FBQ1ZDLFlBQVlWO0lBQ2Q7SUFFQSxJQUFJSCxRQUFRO1FBQ1YsTUFBTWMsT0FBTyxNQUFNbkIsc0RBQVlBLENBQXdCO1lBQ3JEb0IsT0FBT2pCO1lBQ1BrQixXQUFXO2dCQUFFaEI7Z0JBQVFpQixPQUFPO29CQUFDUDtpQkFBSztZQUFDO1FBQ3JDO1FBQ0EsT0FBT0ksS0FBS0ksWUFBWSxDQUFDQyxJQUFJLENBQUNDLEVBQUU7SUFDbEMsT0FBTztRQUNMLE1BQU1OLE9BQU8sTUFBTW5CLHNEQUFZQSxDQUFzQjtZQUNuRG9CLE9BQU9sQjtZQUNQbUIsV0FBVztnQkFBRUssT0FBTztvQkFBRUosT0FBTzt3QkFBQ1A7cUJBQUs7Z0JBQUM7WUFBRTtRQUN4QztRQUNBLE9BQU9JLEtBQUtRLFVBQVUsQ0FBQ0gsSUFBSSxDQUFDQyxFQUFFO0lBQ2hDO0FBQ0Y7QUFFQSwwQkFBMEI7QUFFMUIsTUFBTUcsaUJBQWlCLHFFQUdELE9BQWQzQixlQUFjO0FBS2YsZUFBZTRCLFFBQVF4QixNQUFjO0lBQzFDLE1BQU1jLE9BQU8sTUFBTW5CLHNEQUFZQSxDQUF3QjtRQUNyRG9CLE9BQU9RO1FBQ1BQLFdBQVc7WUFBRWhCO1FBQU87SUFDdEI7SUFDQSxPQUFPYyxLQUFLSyxJQUFJO0FBQ2xCO0FBRUEsTUFBTU0sNEJBQTRCLG9KQUlWLE9BQWQ3QixlQUFjO0FBTWpCLGVBQWU4QixlQUNwQjFCLE1BQWMsRUFDZDJCLE1BQWM7SUFFZCxNQUFNYixPQUFPLE1BQU1uQixzREFBWUEsQ0FBNkM7UUFDMUVvQixPQUFPVTtRQUNQVCxXQUFXO1lBQ1RoQjtZQUNBNEIsU0FBUztnQkFBQ0Q7YUFBTztRQUNuQjtJQUNGO0lBQ0EsT0FBT2IsS0FBS2UsZUFBZSxDQUFDVixJQUFJO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvY2FydC50cz9jMzk1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNob3BpZnlGZXRjaCB9IGZyb20gXCIuL3Nob3BpZnlcIjtcblxuLy8gRGVmaW5lIHRoZSBzaGFwZSBvZiB0aGUgY2FydCBmb3IgVHlwZVNjcmlwdFxuZXhwb3J0IHR5cGUgU2hvcGlmeUNhcnQgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIGNoZWNrb3V0VXJsOiBzdHJpbmc7XG4gIGNvc3Q6IHtcbiAgICB0b3RhbEFtb3VudDoge1xuICAgICAgYW1vdW50OiBzdHJpbmc7XG4gICAgICBjdXJyZW5jeUNvZGU6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBsaW5lczoge1xuICAgIGVkZ2VzOiB7XG4gICAgICBub2RlOiB7XG4gICAgICAgIGlkOiBzdHJpbmc7XG4gICAgICAgIHF1YW50aXR5OiBudW1iZXI7XG4gICAgICAgIG1lcmNoYW5kaXNlOiB7XG4gICAgICAgICAgaWQ6IHN0cmluZztcbiAgICAgICAgICB0aXRsZTogc3RyaW5nO1xuICAgICAgICAgIHByb2R1Y3Q6IHtcbiAgICAgICAgICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgICAgICAgICBmZWF0dXJlZEltYWdlOiB7XG4gICAgICAgICAgICAgIHVybDogc3RyaW5nO1xuICAgICAgICAgICAgICBhbHRUZXh0OiBzdHJpbmc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgICAgcHJpY2U6IHtcbiAgICAgICAgICAgIGFtb3VudDogc3RyaW5nO1xuICAgICAgICAgICAgY3VycmVuY3lDb2RlOiBzdHJpbmc7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVtdO1xuICB9O1xufTtcblxuY29uc3QgQ0FSVF9GUkFHTUVOVCA9IGBcbiAgaWRcbiAgY2hlY2tvdXRVcmxcbiAgY29zdCB7XG4gICAgdG90YWxBbW91bnQge1xuICAgICAgYW1vdW50XG4gICAgICBjdXJyZW5jeUNvZGVcbiAgICB9XG4gIH1cbiAgbGluZXMoZmlyc3Q6IDEwMCkge1xuICAgIGVkZ2VzIHtcbiAgICAgIG5vZGUge1xuICAgICAgICBpZFxuICAgICAgICBxdWFudGl0eVxuICAgICAgICBtZXJjaGFuZGlzZSB7XG4gICAgICAgICAgLi4uIG9uIFByb2R1Y3RWYXJpYW50IHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgICB0aXRsZVxuICAgICAgICAgICAgcHJvZHVjdCB7XG4gICAgICAgICAgICAgIHRpdGxlXG4gICAgICAgICAgICAgIGZlYXR1cmVkSW1hZ2Uge1xuICAgICAgICAgICAgICAgIHVybFxuICAgICAgICAgICAgICAgIGFsdFRleHRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJpY2Uge1xuICAgICAgICAgICAgICBhbW91bnRcbiAgICAgICAgICAgICAgY3VycmVuY3lDb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5gO1xuXG4vLyBFeGlzdGluZyBhZGRCdW5kbGVUb0NhcnQgZnVuY3Rpb24uLi5cbnR5cGUgUHJvZHVjdCA9IHtcbiAgaWQ6IHN0cmluZztcbiAgdmFyaWFudElkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG59O1xuXG5jb25zdCBDUkVBVEVfQ0FSVF9NVVRBVElPTiA9IGBcbiAgbXV0YXRpb24gY2FydENyZWF0ZSgkaW5wdXQ6IENhcnRJbnB1dCEpIHtcbiAgICBjYXJ0Q3JlYXRlKGlucHV0OiAkaW5wdXQpIHtcbiAgICAgIGNhcnQge1xuICAgICAgICAke0NBUlRfRlJBR01FTlR9XG4gICAgICB9XG4gICAgfVxuICB9XG5gO1xuXG5jb25zdCBBRERfVE9fQ0FSVF9NVVRBVElPTiA9IGBcbiAgbXV0YXRpb24gY2FydExpbmVzQWRkKCRjYXJ0SWQ6IElEISwgJGxpbmVzOiBbQ2FydExpbmVJbnB1dCFdISkge1xuICAgIGNhcnRMaW5lc0FkZChjYXJ0SWQ6ICRjYXJ0SWQsIGxpbmVzOiAkbGluZXMpIHtcbiAgICAgIGNhcnQge1xuICAgICAgICR7Q0FSVF9GUkFHTUVOVH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbmA7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRCdW5kbGVUb0NhcnQoXG4gIGNhcnRJZDogc3RyaW5nIHwgbnVsbCxcbiAgdGVzdGVyQm94VmFyaWFudElkOiBzdHJpbmcsXG4gIGJ1bmRsZUl0ZW1zOiBQcm9kdWN0W11cbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IGxpbmVJdGVtUHJvcGVydGllcyA9IGJ1bmRsZUl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+ICh7XG4gICAga2V5OiBgVGVzdGVyICR7aW5kZXggKyAxfWAsXG4gICAgdmFsdWU6IGl0ZW0udGl0bGUsXG4gIH0pKTtcblxuICBjb25zdCBsaW5lID0ge1xuICAgIG1lcmNoYW5kaXNlSWQ6IHRlc3RlckJveFZhcmlhbnRJZCxcbiAgICBxdWFudGl0eTogMSxcbiAgICBhdHRyaWJ1dGVzOiBsaW5lSXRlbVByb3BlcnRpZXMsXG4gIH07XG5cbiAgaWYgKGNhcnRJZCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBzaG9waWZ5RmV0Y2g8eyBjYXJ0TGluZXNBZGQ6IGFueSB9Pih7XG4gICAgICBxdWVyeTogQUREX1RPX0NBUlRfTVVUQVRJT04sXG4gICAgICB2YXJpYWJsZXM6IHsgY2FydElkLCBsaW5lczogW2xpbmVdIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGEuY2FydExpbmVzQWRkLmNhcnQuaWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHNob3BpZnlGZXRjaDx7IGNhcnRDcmVhdGU6IGFueSB9Pih7XG4gICAgICBxdWVyeTogQ1JFQVRFX0NBUlRfTVVUQVRJT04sXG4gICAgICB2YXJpYWJsZXM6IHsgaW5wdXQ6IHsgbGluZXM6IFtsaW5lXSB9IH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGEuY2FydENyZWF0ZS5jYXJ0LmlkO1xuICB9XG59XG5cbi8vICoqTkVXIEZVTkNUSU9OUyBCRUxPVyoqXG5cbmNvbnN0IEdFVF9DQVJUX1FVRVJZID0gYFxuICBxdWVyeSBnZXRDYXJ0KCRjYXJ0SWQ6IElEISkge1xuICAgIGNhcnQoaWQ6ICRjYXJ0SWQpIHtcbiAgICAgICR7Q0FSVF9GUkFHTUVOVH1cbiAgICB9XG4gIH1cbmA7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYXJ0KGNhcnRJZDogc3RyaW5nKTogUHJvbWlzZTxTaG9waWZ5Q2FydCB8IG51bGw+IHtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IHNob3BpZnlGZXRjaDx7IGNhcnQ6IFNob3BpZnlDYXJ0IH0+KHtcbiAgICBxdWVyeTogR0VUX0NBUlRfUVVFUlksXG4gICAgdmFyaWFibGVzOiB7IGNhcnRJZCB9LFxuICB9KTtcbiAgcmV0dXJuIGRhdGEuY2FydDtcbn1cblxuY29uc3QgUkVNT1ZFX0ZST01fQ0FSVF9NVVRBVElPTiA9IGBcbiAgbXV0YXRpb24gY2FydExpbmVzUmVtb3ZlKCRjYXJ0SWQ6IElEISwgJGxpbmVJZHM6IFtJRCFdISkge1xuICAgIGNhcnRMaW5lc1JlbW92ZShjYXJ0SWQ6ICRjYXJ0SWQsIGxpbmVJZHM6ICRsaW5lSWRzKSB7XG4gICAgICBjYXJ0IHtcbiAgICAgICAgJHtDQVJUX0ZSQUdNRU5UfVxuICAgICAgfVxuICAgIH1cbiAgfVxuYDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZUZyb21DYXJ0KFxuICBjYXJ0SWQ6IHN0cmluZyxcbiAgbGluZUlkOiBzdHJpbmdcbik6IFByb21pc2U8U2hvcGlmeUNhcnQ+IHtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IHNob3BpZnlGZXRjaDx7IGNhcnRMaW5lc1JlbW92ZTogeyBjYXJ0OiBTaG9waWZ5Q2FydCB9IH0+KHtcbiAgICBxdWVyeTogUkVNT1ZFX0ZST01fQ0FSVF9NVVRBVElPTixcbiAgICB2YXJpYWJsZXM6IHtcbiAgICAgIGNhcnRJZCxcbiAgICAgIGxpbmVJZHM6IFtsaW5lSWRdLFxuICAgIH0sXG4gIH0pO1xuICByZXR1cm4gZGF0YS5jYXJ0TGluZXNSZW1vdmUuY2FydDtcbn1cbiJdLCJuYW1lcyI6WyJzaG9waWZ5RmV0Y2giLCJDQVJUX0ZSQUdNRU5UIiwiQ1JFQVRFX0NBUlRfTVVUQVRJT04iLCJBRERfVE9fQ0FSVF9NVVRBVElPTiIsImFkZEJ1bmRsZVRvQ2FydCIsImNhcnRJZCIsInRlc3RlckJveFZhcmlhbnRJZCIsImJ1bmRsZUl0ZW1zIiwibGluZUl0ZW1Qcm9wZXJ0aWVzIiwibWFwIiwiaXRlbSIsImluZGV4Iiwia2V5IiwidmFsdWUiLCJ0aXRsZSIsImxpbmUiLCJtZXJjaGFuZGlzZUlkIiwicXVhbnRpdHkiLCJhdHRyaWJ1dGVzIiwiZGF0YSIsInF1ZXJ5IiwidmFyaWFibGVzIiwibGluZXMiLCJjYXJ0TGluZXNBZGQiLCJjYXJ0IiwiaWQiLCJpbnB1dCIsImNhcnRDcmVhdGUiLCJHRVRfQ0FSVF9RVUVSWSIsImdldENhcnQiLCJSRU1PVkVfRlJPTV9DQVJUX01VVEFUSU9OIiwicmVtb3ZlRnJvbUNhcnQiLCJsaW5lSWQiLCJsaW5lSWRzIiwiY2FydExpbmVzUmVtb3ZlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/cart.ts\n"));

/***/ })

});